---
title: "ampelos"
output: github_document
---



```{r, echo=F, message=F, warning=F}

library(combinat)
library(compare)
library(dplyr)

if (FALSE) {
  # generate all possible combinations of 3 counts of 0 to 5 spiders
  combo.df <- as.data.frame( combn(c(0,0,0,1,1,1,2,2,2,3,3,3,4,4,4,5,5,5), 3) )
  #shortCombo <- as.data.frame( combn(c(0,1,2,3,4,5),3) )  # does not generate "0,0,0"
  combo816.df <- combo.df 
  # result is 3 rows with 816 columns representing the combinations
  
  # remove duplicate triplets
  columns <- ncol(combo.df)
  for (i in 1:columns) {
    k <- i+1
    if (k > columns) {
      break
    } else {
      for (j in columns:k) {         # walk backwards along the columns
        c.list <- compare(as.list(combo.df[,i]), as.list(combo.df[,j]), ignoreOrder=TRUE)
        if ( c.list[[1]] == TRUE) {
          combo.df[,j] <- NULL                 # delete the duplicate column
        }
      }
    }
    columns <- ncol(combo.df)
    #column.list[[i]] <- combo.df[,i]
  }
  
  # write the unique species count combinations to disc
  write.table(combo.df, './output/speciesCombinations.csv', 
              append = FALSE, sep = ",", col.names = TRUE)
  
} else {  
  # read the unique species count combinations from disc
  uniqueCombo56.df <- read.table('./output/speciesCombinations.csv', sep = ",")
}

############################################################################

#list1 <- list(c(1,1,0))
#list2 <- list(c(0,1,1))
#compare(list1, list2, ignoreOrder=TRUE)

```


```{r kable, results='asis', echo=FALSE, message=F, warning=F}

# compute the mean of the 3 counts and add a column (56 combinations)
uC.df <- as.data.frame(t(uniqueCombo56.df)) %>% 
  dplyr::rename(obsOne = `1`) %>%
  dplyr::rename(obsTwo = `2`) %>%
  dplyr::rename(obsThree = `3`) %>% 
  dplyr::rowwise() %>% 
  dplyr::mutate(conjecture= (paste(obsOne, obsTwo, obsThree, sep='-'))) %>% 
  dplyr::mutate(conjectureMean = as.numeric( mean(c(obsOne, obsTwo, obsThree))) ) 
  
# 'I' means 'inhibit' : https://stackoverflow.com/questions/9547518/create-a-data-frame-where-a-column-is-a-list

# uC.df['p'] <- NA
# uC.df['ways'] <- NA
# uC.df['plausibility'] <- NA


knitr::kable(uC.df)

```

```{r}

# compute the frequency of each mean and add columns for count and frequency
# https://stackoverflow.com/questions/24576515/relative-frequencies-proportions-with-dplyr
meanFreq16.df <- uC.df %>%
  dplyr::group_by(conjectureMean) %>%
  dplyr::summarise (countWays = n()) %>%
  dplyr::mutate(freq = countWays / sum(countWays)) 

#meanFreq16.df <- meanFreq.df %>%
  #dplyr::rowwise() %>%
  #dplyr::mutate(conjectureMeanC = paste(as.character(conjectureMean), "C", sep=""))
  #dplyr::mutate(conjectureMeanC = formatC(conjectureMean, digits=7, format = "f"))

# to go the the next level with 16x16 conjectures implies 1.84x10^19 observations... (don't do that)

# instead, reduce to means in 6 domains

group1.df <- meanFreq16.df %>%
  dplyr::filter(conjectureMean >= 0 & conjectureMean <= .5)
group2.df <- meanFreq16.df %>%
  dplyr::filter(conjectureMean > .5 & conjectureMean <= 1.5)
group3.df <- meanFreq16.df %>%
  dplyr::filter(conjectureMean > 1.5 & conjectureMean <= 2.5)
group4.df <- meanFreq16.df %>%
  dplyr::filter(conjectureMean > 2.5 & conjectureMean <= 3.5)
group5.df <- meanFreq16.df %>%
  dplyr::filter(conjectureMean > 3.5 & conjectureMean <= 4.5)
group6.df <- meanFreq16.df %>%
  dplyr::filter(conjectureMean > 4.5 & conjectureMean <= 5)

# sum the ways and the frequency for each domain
group1.df <- group1.df %>%
  dplyr::summarise(countWays=sum(countWays), freq=sum(freq))
group2.df <- group2.df %>%
  dplyr::summarise(countWays=sum(countWays), freq=sum(freq))
group3.df <- group3.df %>%
  dplyr::summarise(countWays=sum(countWays), freq=sum(freq))
group4.df <- group4.df %>%
  dplyr::summarise(countWays=sum(countWays), freq=sum(freq))
group5.df <- group5.df %>%
  dplyr::summarise(countWays=sum(countWays), freq=sum(freq))
group6.df <- group6.df %>%
  dplyr::summarise(countWays=sum(countWays), freq=sum(freq))

# assemble into one df
conjecture.df <- dplyr::tribble(~conjecture, ~countWays, ~freq,  
                      "group1", group1.df[[1,1]], group1.df[[1,2]],
                      "group2", group2.df[[1,1]], group2.df[[1,2]],
                      "group3", group3.df[[1,1]], group3.df[[1,2]],
                      "group4", group4.df[[1,1]], group4.df[[1,2]],
                      "group5", group5.df[[1,1]], group5.df[[1,2]],
                      "group6", group6.df[[1,1]], group6.df[[1,2]])




```


```{r}

nextObservation <- function(vector1, vector2) {
  # compute the next generation
  # https://stackoverflow.com/questions/11388359/unique-combination-of-all-elements-from-two-or-more-vectors
  
  # testing....
  #vector1 <- c('a', 'b', 'c')
  #vector2 <- c('x', 'y', 'z')
  #
  if (FALSE) {
    test.df <- dplyr::tribble(~obs, ~x, ~y,  
                             "obs1", 'a', 'a',
                              "obs2", 'b', 'b',
                              "obs3", 'c', 'c',
                              "obs4", 'd', 'd',
                              "obs5", 'e', 'e',
                              "obs6", 'f', 'f')
  }
  
  
  
  library(tidyr)
  
  # find all unique combinations
  #next.df <- as.data.frame(tidyr::crossing(vector1, vector2))
  # remove the mirror images (because the lists are exactly the same)
  
  withDuplicates.df <- as.data.frame(tidyr::crossing(test.df$x, test.df$y))
  
  noDuplicates.df <- removeDup(as.data.frame(t(withDuplicates.df)))
  
  noDuplicates.df <- as.data.frame(t(noDuplicates.df))

}

```


```{r}

removeDup <- function(df) {
  
  # remove columns containing duplicate row data interpreted as a list
  #       col1 col2 col3
  # row1   1    0    1
  # row2   0    0    0
  # row3   1    1    1
  #                  ^--- duplicate
  
  # testing.....
  # t.df <- as.data.frame(t(withDuplicates.df))
  #df <- t.df
  
  columns <- ncol(df)
  for (i in 1:columns) {
    k <- i+1
    if (k > columns) {
      break
    } else {
      for (j in columns:k) {         # walk backwards along the columns
        c.list <- compare(df[,i], df[,j], ignoreOrder=TRUE)
        if ( c.list[[1]] == TRUE) {
          df[,j] <- NULL                 # delete the duplicate column
        }
      }
    }
    columns <- ncol(df)
  }
  
  return(df)
  
}


```


```{r}

library(dplyr)

source.url <- c("https://raw.githubusercontent.com/cordphelps/ampelos/master/data/bugs.csv")
bugs.df <- read.csv(source.url, header=TRUE, row.names=NULL)

# interesting / obscure stuff about creating a dataframe column that
# that contain lists
# http://stat545.com/block023_dplyr-do.html
# http://ijlyttle.github.io/isugg_purrr/presentation.html#(18)
# https://stackoverflow.com/questions/42179298/double-nesting-with-tidyverse-and-purrr
# (defer for now)

# build a list of evidence by transect, by cluster, by week, by time-of-day (ref: buildClustersByWeek() )

if (FALSE) {
df <- bugs.df
	i <- 1
	species <- "Thomisidae..crab.spider."
	formula.t <- (~ transect == "oakMargin" )
	formula.w <- (~ week == 25 )
	formula.s <- (~ Thomisidae..crab.spider. > 0 )
}

	transectString <- paste("~transect=='", t, "'", sep="")
	formula.t <- as.formula(transectString)
	#transectExp <- parse(text = transectString)

	speciesString <- paste("~", species, ">0", sep="")
	formula.s <- as.formula(speciesString)
	
	formula.cluster1 <- paste("~ position==1 | position==2 | position==3 | position==4", sep="")
	formula.cluster2 <- paste("~ position==5 | position==6 | position==7", sep="")
	formula.cluster3 <- paste("~ position==8 | position==9 | position==10", sep="")

  weeks.vector <- getWeeks(df)
  timeList <- c('am', 'pm')
  clusterFormulaList <- c(formula.cluster1, formula.cluster2, formula.cluster3)

  for (i in 1:length(weeks.vector)) {
			w <- weeks.vector[[i]]
			for (j in timeList) {
			  for (k in clusterFormulaList) {
			    weekString <- paste("~week==", weeks.vector[[i]], sep="") # dynamically create an expression to filter by week
			    formula.w <- as.formula(weekString)
			    dataList[[i]] <- kmReduce(df, ft=formula.t, fw=formula.w, fs=formula.s, intWeek=w)

			    clusterList <- dataList[[i]]
			    dataList[[i]] <- kmAssignClusters(list=clusterList, cn=cn)
			  }
			}
	  }
                   

  


```


```{r}

evidence <- function() {
  
  
  oakCL1w36pm.list <- bugs.df %>%
    dplyr::filter(transect == "oakMargin" & week == 23 & time == 'pm') %>%
    dplyr::filter(position==1 | position==2 | position==3 | position==4) %>%
    dplyr::group_by(julian) %>%
    dplyr::summarise(aveSpiders = mean(Thomisidae..crab.spider.) ) %>%
    dplyr::select(-julian) %>%  # remove julian column
    as.list()                   # list now contains the average for
                                # each of the julian days in the week
  
  
}

```

