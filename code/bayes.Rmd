---
title: "ampelos"
output: github_document
---



```{r, echo=F, message=F, warning=F}

library(combinat)
library(compare)
library(dplyr)

if (FALSE) {
  # generate all possible combinations of 3 counts of 0 to 5 spiders
  combo.df <- as.data.frame( combn(c(0,0,0,1,1,1,2,2,2,3,3,3,4,4,4,5,5,5), 3) )
  #shortCombo <- as.data.frame( combn(c(0,1,2,3,4,5),3) )  # does not generate "0,0,0"
  combo816.df <- combo.df 
  # result is 3 rows with 816 columns representing the combinations
  
  # remove duplicate triplets
  columns <- ncol(combo.df)
  for (i in 1:columns) {
    k <- i+1
    if (k > columns) {
      break
    } else {
      for (j in columns:k) {         # walk backwards along the columns
        c.list <- compare(as.list(combo.df[,i]), as.list(combo.df[,j]), ignoreOrder=TRUE)
        if ( c.list[[1]] == TRUE) {
          combo.df[,j] <- NULL                 # delete the duplicate column
        }
      }
    }
    columns <- ncol(combo.df)
    #column.list[[i]] <- combo.df[,i]
  }
  
  # write the unique species count combinations to disc
  write.table(combo.df, './output/speciesCombinations.csv', 
              append = FALSE, sep = ",", col.names = TRUE)
  
} else {  
  # read the unique species count combinations from disc
  uniqueCombo56.df <- read.table('./output/speciesCombinations.csv', sep = ",")
}

############################################################################

#list1 <- list(c(1,1,0))
#list2 <- list(c(0,1,1))
#compare(list1, list2, ignoreOrder=TRUE)

```


```{r kable, results='asis', echo=FALSE, message=F, warning=F}

# compute the sum of the 3 counts and add a column (56 combinations)
uC.df <- as.data.frame(t(uniqueCombo56.df)) %>% 
  dplyr::rename(obsOne = `1`) %>%
  dplyr::rename(obsTwo = `2`) %>%
  dplyr::rename(obsThree = `3`) %>% 
  dplyr::rowwise() %>% 
  dplyr::mutate(conjecture= (paste(obsOne, obsTwo, obsThree, sep='-'))) %>% 
  dplyr::mutate(conjectureSum = as.numeric( sum(c(obsOne, obsTwo, obsThree))) ) 
  
# 'I' means 'inhibit' : https://stackoverflow.com/questions/9547518/create-a-data-frame-where-a-column-is-a-list

# uC.df['p'] <- NA
# uC.df['ways'] <- NA
# uC.df['plausibility'] <- NA


knitr::kable(uC.df)

```

```{r}

# compute the frequency of each sum and add columns for count and frequency
# https://stackoverflow.com/questions/24576515/relative-frequencies-proportions-with-dplyr
meanFreq16.df <- uC.df %>%
  dplyr::group_by(conjectureSum) %>%
  dplyr::summarise (countWays = n()) %>%
  dplyr::mutate(freq = countWays / sum(countWays)) 

#meanFreq16.df <- meanFreq.df %>%
  #dplyr::rowwise() %>%
  #dplyr::mutate(conjectureMeanC = paste(as.character(conjectureMean), "C", sep=""))
  #dplyr::mutate(conjectureMeanC = formatC(conjectureMean, digits=7, format = "f"))

# to go the the next level with 16x16 conjectures implies 1.84x10^19 observations... (don't do that)

# instead, reduce to means in 6 domains

group1.df <- meanFreq16.df %>%
  dplyr::filter(conjectureMean >= 0 & conjectureMean <= .5)
group2.df <- meanFreq16.df %>%
  dplyr::filter(conjectureMean > .5 & conjectureMean <= 1.5)
group3.df <- meanFreq16.df %>%
  dplyr::filter(conjectureMean > 1.5 & conjectureMean <= 2.5)
group4.df <- meanFreq16.df %>%
  dplyr::filter(conjectureMean > 2.5 & conjectureMean <= 3.5)
group5.df <- meanFreq16.df %>%
  dplyr::filter(conjectureMean > 3.5 & conjectureMean <= 4.5)
group6.df <- meanFreq16.df %>%
  dplyr::filter(conjectureMean > 4.5 & conjectureMean <= 5)

# sum the ways and the frequency for each domain
group1.df <- group1.df %>%
  dplyr::summarise(countWays=sum(countWays), freq=sum(freq))
group2.df <- group2.df %>%
  dplyr::summarise(countWays=sum(countWays), freq=sum(freq))
group3.df <- group3.df %>%
  dplyr::summarise(countWays=sum(countWays), freq=sum(freq))
group4.df <- group4.df %>%
  dplyr::summarise(countWays=sum(countWays), freq=sum(freq))
group5.df <- group5.df %>%
  dplyr::summarise(countWays=sum(countWays), freq=sum(freq))
group6.df <- group6.df %>%
  dplyr::summarise(countWays=sum(countWays), freq=sum(freq))

# assemble into one df
conjecture.df <- dplyr::tribble(~conjecture, ~countWays, ~freq,  
                      "group1", group1.df[[1,1]], group1.df[[1,2]],
                      "group2", group2.df[[1,1]], group2.df[[1,2]],
                      "group3", group3.df[[1,1]], group3.df[[1,2]],
                      "group4", group4.df[[1,1]], group4.df[[1,2]],
                      "group5", group5.df[[1,1]], group5.df[[1,2]],
                      "group6", group6.df[[1,1]], group6.df[[1,2]])




```


```{r}

nextObservation <- function(vector1, vector2) {
  # compute the next generation
  # https://stackoverflow.com/questions/11388359/unique-combination-of-all-elements-from-two-or-more-vectors
  
  # testing....
  #vector1 <- c('a', 'b', 'c')
  #vector2 <- c('x', 'y', 'z')
  #
  if (FALSE) {
    test.df <- dplyr::tribble(~obs, ~x, ~y,  
                             "obs1", 'a', 'a',
                              "obs2", 'b', 'b',
                              "obs3", 'c', 'c',
                              "obs4", 'd', 'd',
                              "obs5", 'e', 'e',
                              "obs6", 'f', 'f')
  }
  
  
  
  library(tidyr)
  
  # find all unique combinations
  #next.df <- as.data.frame(tidyr::crossing(vector1, vector2))
  # remove the mirror images (because the lists are exactly the same)
  
  withDuplicates.df <- as.data.frame(tidyr::crossing(test.df$x, test.df$y))
  
  noDuplicates.df <- removeDup(as.data.frame(t(withDuplicates.df)))
  
  noDuplicates.df <- as.data.frame(t(noDuplicates.df))

}

```


```{r}

removeDup <- function(df) {
  
  # remove columns containing duplicate row data interpreted as a list
  #       col1 col2 col3
  # row1   1    0    1
  # row2   0    0    0
  # row3   1    1    1
  #                  ^--- duplicate
  
  # testing.....
  # t.df <- as.data.frame(t(withDuplicates.df))
  #df <- t.df
  
  columns <- ncol(df)
  for (i in 1:columns) {
    k <- i+1
    if (k > columns) {
      break
    } else {
      for (j in columns:k) {         # walk backwards along the columns
        c.list <- compare(df[,i], df[,j], ignoreOrder=TRUE)
        if ( c.list[[1]] == TRUE) {
          df[,j] <- NULL                 # delete the duplicate column
        }
      }
    }
    columns <- ncol(df)
  }
  
  return(df)
  
}


```


```{r}

source("./jaccard-similarity.R")  # (gets the function getWeeks() )
library(dplyr)

library(ggplot2)


source.url <- c("https://raw.githubusercontent.com/cordphelps/ampelos/master/data/bugs.csv")
bugs.df <- read.csv(source.url, header=TRUE, row.names=NULL)

# interesting / obscure stuff about creating a dataframe column 
# that contains lists
# http://stat545.com/block023_dplyr-do.html
# http://ijlyttle.github.io/isugg_purrr/presentation.html#(18)
# https://stackoverflow.com/questions/42179298/double-nesting-with-tidyverse-and-purrr
# (defer for now)

# build a list of evidence by transect, by cluster, by week, by time-of-day (ref: buildClustersByWeek() )

if (TRUE) {
df <- bugs.df
	i <- 1
	# formula.w <- (~ week == 25 )
	formula.s <- (~ Thomisidae..crab.spider. > 0 )
}

  species <- "Thomisidae..crab.spider."
	speciesString <- paste("~", species, ">0", sep="")
	formula.s <- as.formula(speciesString)
	
	formula.cluster1 <- paste("~ position==1 | position==2 | position==3 | position==4", sep="")
	formula.cluster2 <- paste("~ position==5 | position==6 | position==7", sep="")
	formula.cluster3 <- paste("~ position==8 | position==9 | position==10", sep="")

  weeks.vector <- getWeeks(bugs.df)
  transectList <- c('oakMargin', 'control')
  timeList <- c('am', 'pm')
  clusterFormulaList <- c(formula.cluster1, formula.cluster2, formula.cluster3)

  total.df <- NULL
    
  for (i in 1:length(weeks.vector)) {
    
    for (n in 1:length(transectList)) {
			
			for (j in 1:length(timeList)) {
			  
			  for (k in 1:length(clusterFormulaList)) {
			    if (k==1) {
			      clusterListChars <- "one" 
			      } else if (k==2) {
			      clusterListChars <- "two"
			      } else {
			      clusterListChars <- "three"
			      }
			    
			      twtString <- paste("~ week==", weeks.vector[[i]], 
			                       " & time=='", timeList[[j]], "'", sep="")
			    
			      clusterString <- paste(clusterFormulaList[[k]], sep="")
			      
			      dailySum.list <- dailySumByClusterTimeWeek(bugs.df, 
			                     ft=as.formula(twtString),
			                     fc=as.formula(clusterString))
			      
			      # create a df record for each of the averages in the list
			      for (m in 1:length(dailySum.list[[1]])) {
			        temp.df <- data.frame(weeks.vector[[i]],
			                              transectList[[n]],
			                              timeList[[j]], 
			                              clusterListChars,
			                              dailySum.list[[1]][[m]]
			                            )
			        # column names need to match for rbind() to work
			        names(temp.df) <- c("week", "transect", "time", "cluster", "totalSpiders")
			        
			        # tack it on
			        # https://stackoverflow.com/questions/35366187/how-to-write-if-else-statements-if-dataframe-is-empty
			        if (!exists('total.df')) {
			          total.df <- temp.df
			          # (so, on the first pass the column names are cool)
			        } else {
			          total.df <- rbind(total.df, temp.df)
			        }
			        
			      } # end create a df record
			      
			  } # clusterFormulaList
			} # timeList
    } # transectList
  } # weeks.vector
  
  # remove the 'am' data points
  #ave.df <- ave.df %>%
    #dplyr::filter(time=='am')
  
  plotWeekly(total.df)
  
  liklihood.df <- generateLiklihood(df=total.df)
  
  plotLiklihood(df=liklihood.df)


```


```{r}

plotLiklihood <- function(df) {
  
  library(gridExtra)
  
  gg <- ggplot(df, aes(x=seasonalTimeframe, y=liklihood)) +
    
    geom_jitter(aes(colour = factor(cluster),
                    fill = factor(cluster), 
                    alpha = .9 ), 
                shape = 21, size=5) +

      ylim(c(0, 1)) + 
      expand_limits(y=c(0,1)) + 
      #scale_x_continuous(breaks=seq(22,40,2)) +
      labs(title=paste("liklihood of oakMargin effect on the\nspider population", sep=""),
        subtitle=paste("subtitle ", sep=""), 
          y="probability", 
          x="seasonal timeframe", 
          caption = paste("", sep="") ) +
    
      scale_color_manual(name="cluster postions", labels = c("1-4", "5-7", "8-10"), values = c("red", "green", "blue")) +
    
      scale_x_discrete(labels=c("one" = "weeks 23-25", "two" = "weeks 26-30",
                              "three" = "weeks 31-34")) +
    
      guides(fill=FALSE) +
      guides(alpha=FALSE) +
      guides(factor=FALSE) +
    
      #theme(legend.position="none") +
      theme(legend.position = "bottom", legend.direction = "horizontal") +
      theme_bw() +
      coord_fixed() # control the aspect ratio of the output


  return(grid.arrange(gg, ncol=1, nrow=1))
  
  
}


```



```{r}

generateLiklihood <- function(df) {

library(rethinking)

# build and return a df of liklihood (the probability that the
# spider population is influenced by the oakMargin) by cluster by week


# estimate different mean populations across 3 groups of weeks reflecting the 
# seasonal population decline
# 
# week 23, 24, 25           : mean 75, sd 15
# week 26, 27, 28, 29, 30   : mean 50, sd 8
# week 31, 32, 33, 34       : mean 15, sd 2

  # generate nrow(ave.df) random population numbers with a normal distribution
    # t.df$population <- rnorm(nrow(t.df), mean=50, sd=5)


  df$population <- ifelse( (df$week>22 & df$week<26), rnorm(nrow(df), mean=75, sd=15),
                     ifelse( (df$week>25 & df$week<31), rnorm(nrow(df), mean=25, sd=8),
                      rnorm(nrow(df), mean=15, sd=2)) )

df$population <- as.integer(df$population)
# R code 10.40
df$log_pop <- log(df$population)
df$contact_high <- ifelse( df$transect=="oakMargin" , 1 , 0 )

cl.st.list <- list()  # for each cluster  
                      # build list of dataframes represting the  
                      # seasonal population 
cl.st.list[[1]] <- df %>% dplyr::filter(week < 26 & cluster == 'one')
cl.st.list[[2]] <- df %>% dplyr::filter(week > 25 & week < 31 & cluster == 'one')
cl.st.list[[3]] <- df %>% dplyr::filter(week > 30 & cluster == 'one')

cl.st.list[[4]] <- df %>% dplyr::filter(week < 26 & cluster == 'two')
cl.st.list[[5]] <- df %>% dplyr::filter(week > 25 & week < 31 & cluster == 'two')
cl.st.list[[6]] <- df %>% dplyr::filter(week > 30 & cluster == 'two')

cl.st.list[[7]] <- df %>% dplyr::filter(week < 26 & cluster == 'three')
cl.st.list[[8]] <- df %>% dplyr::filter(week > 25 & week < 31 & cluster == 'three')
cl.st.list[[9]] <- df %>% dplyr::filter(week > 30 & cluster == 'three')

# plotWeekly(total.df)

#########
## the model
#########

# the number of trapped spiders increases with log(population)

# the number of trapped spiders increases with natural habital support

# the impact of population on trapped spiders increases with natural habital support

# the number of trapped spiders increases with daylight

liklihood.df <- NULL
    
  for (i in 1:length(cl.st.list)) {  # build model for each seasonal timeframe
    
      ## R code 10.41
      m10.10 <- map(
          alist(
              totalSpiders ~ dpois( lambda ),
              #totalSpiders ~ dgamma( lambda ),
              log(lambda) <- a + bp*log_pop +
                  bc*contact_high + bpc*contact_high*log_pop,
              a ~ dnorm(0,100),
              c(bp,bc,bpc) ~ dnorm(0,1)
          ),
          data=cl.st.list[[i]] )

      ## R code 10.42
      precis(m10.10,corr=TRUE)
      plot(precis(m10.10))  # line graph

      ## R code 10.43
      post <- extract.samples(m10.10)
      lambda_high <- exp( post$a + post$bc + (post$bp + post$bpc)*2)
      lambda_low <- exp( post$a + post$bp*2 )

      plot(post)  # (faceted plot)

      fig10.8 <- data.frame(lh=lambda_high, ll=lambda_low, delta=lambda_high-lambda_low)

      ## R code 10.44
      diff <- lambda_high - lambda_low
      # sum(diff > 0)/length(diff)
      
      # figure out which cluster we are referring to
      if (i < 4) {
        cluster <- "one" 
      } else if (i > 6) {
        cluster <- "three"
      } else {
        cluster <- "two"
      }
      
      # figure out which seasonal timeframe we are referring to
      if (i == 1 | i == 4 | i == 7) {
        seasonalTimeframe <- "one" 
      } else if (i == 2 | i == 5 | i == 8) {
        seasonalTimeframe <- "two"
      } else {
        seasonalTimeframe <- "three"
      }      
      
      temp2.df <- data.frame(cluster, seasonalTimeframe, sum(diff > 0)/length(diff) )
      # column names need to match for rbind() to work
			names(temp2.df) <- c("cluster", "seasonalTimeframe", "liklihood")
			        
			 # tack it on
			 if (!exists('liklihood.df')) {
			     liklihood.df <- temp2.df
			     # (so, on the first pass the column names are cool)
			 } else {
			  liklihood.df <- rbind(liklihood.df, temp2.df)
			 }
      
  }

return(liklihood.df)

}


```




```{r}

          

plotWeekly <- function(df) {


  ggplot(df, aes(x=week, y=totalSpiders, colour=cluster)) + 
      #geom_jitter(aes(x=week, y=aveSpiders), width = 0.1, height = 0.1, show.legend = TRUE, shape = 21, size=5, colour = "mediumvioletred", fill = cluster) + 
    
      geom_jitter(aes(colour=cluster, fill = cluster), shape=21, size=5, alpha=.5) +

      ylim(c(0, 31)) + 
      expand_limits(y=c(0,31)) + 
      scale_y_continuous(breaks = seq(min(0), max(31), by = 5)) +
      scale_x_continuous(breaks=seq(22,40,2)) +
      labs(title=paste("total spiders\ntrapped per day", sep=""),
        subtitle=paste("", sep=""), 
          y="spiders per day per trap postion", 
          x="week", 
          caption = paste("", sep="") ) +

      theme(legend.position = "bottom", legend.direction = "horizontal") +
      theme_bw() +
      coord_fixed(ratio=1/4)  # control the aspect ratio of the output; "ratio" refers to the 
                            # ratio of the axis limits themselves



}



```




```{r}

dailySumByClusterTimeWeek <- function(df, ft, fc) {
  
  # build and return a list of daily row average spiders for each week / cluster / time
  
  dailySum.list <- df %>%
    #dplyr::filter(transect == "oakMargin" & week == 23 & time == 'pm') %>%
    #dplyr::filter(position==1 | position==2 | position==3 | position==4) %>%
    dplyr::filter_(ft)  %>%
    dplyr::filter_(fc)  %>%
    dplyr::group_by(julian) %>%
    dplyr::summarise(aveSpiders = sum(Thomisidae..crab.spider.) ) %>%
    dplyr::select(-julian) %>%  # remove julian column
    as.list()                   # list now contains the average for
                                # each of the julian days in the week
  
  return(dailySum.list)
}

```

```{r}

if (FALSE) {
  
  sigma.list <- seq(from=4, to=9, length.out=200)
  post <- expand.grid(mu=mu.list, sigma=sigma.list)
  post$LL < -sapply(1:nrow(post), 
                  function(i) sum(dnorm( d2$height, 
                                         x = mean=post$mu[i], 
                                         sd=post$sigma[i], log=TRUE)))
  post$prod <- post$LL + dnorm(post$mu, 178,20,TRUE) + dunif(post$sigma, 0,50,TRUE)
  post$prob <- exp(post$prod - max(post$prod))
  
  contour_xyz(post$mu, post$sigma, post$prob)
  image_xyz(post$mu, post$sigma, post$prob)

  # code 4.17
  sample.rows <- sample(1:nrow(post), size=1e4, replace=TRUE, prob=post$prob)
  sample.mu <- post$mu[sample.rows]
  sample.sigma <- post$sigma[sample.rows]
  
  plot(sample.mu, sample.sigma, cex=0.5, pch=16, col=col.alpha(rangi2,0.1))
  
  ## R code 4.24
  library(rethinking)
  data(Howell1)
  d <- Howell1
  d2 <- d[ d$age >= 18 , ]

  ## R code 4.25
  flist <- alist(
    height ~ dnorm( mu , sigma ) ,
    mu ~ dnorm( 178 , 20 ) ,
    sigma ~ dunif( 0 , 50 )
    )

  ## R code 4.26
m4.1 <- map( flist , data=d2 )

## R code 4.27
precis( m4.1 )

  
}

```


```{r}

if (FALSE) {
testme.df <- dplyr::tribble(~obs, ~week, ~y,  
                             "obs1", 23, 'a',
                              "obs2", 24, 'b',
                              "obs3", 25, 'c',
                              "obs4", 26, 'd',
                              "obs5", 27, 'e',
                              "obs6", 28, 'f')

testme.df$population <- ifelse( (testme.df$week>23 & testme.df$week<25), 1,
                               ifelse( (testme.df$week>24 & testme.df$week<27), 2,
                                       3))
}

```

