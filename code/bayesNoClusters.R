

densityFacets <- function(tibble, periodString) {
  
  gg <- ggplot(data = tibble, # add the data
       aes(x = positionX / 3.281, y = Thomisidae..crab.spider.,
           color = transect)) +   
    geom_jitter() +
    facet_grid(~transect) +
    #scale_x_continuous(breaks = seq(0, 200, 1)) +
    
    labs(title = paste("thomisidae observations seasonal ",
                        periodString, sep=""),
       x = "trap distance from field edge (m)", 
       y = "count") +
  
    scale_y_continuous(breaks = seq(0, 4, 1)) +
    theme_bw() +
  
    theme(legend.position="none") +
  
    scale_colour_hue(name="transect",    # Legend label, use darker colors
                  breaks=c("SNH", "control"),
                  labels=c("SNH", "control"),
                  l=40)             # Use darker colors, lightness=40
  
  return(gg)
  
}

densityNoFacets <- function(tibble, periodString) {
  
  gg <- ggplot(data = tibble, # add the data
       aes(x = transect, y = Thomisidae..crab.spider., # set x, y coordinates
           color = transect)) +    # color by treatment
    geom_jitter() +
    
    labs(title = paste("thomisidae observations seasonal ",
                        periodString, sep=""),
       x = "transect", 
       y = "counts") +
    
    scale_y_continuous(breaks = seq(0, 4, 1)) +
  
    theme_bw() +
  
    theme(legend.position="none") 
  
  return(gg)
}


errorBars <- function(tibble, periodString, observations) {
  
  # http://www.cookbook-r.com/Graphs/Plotting_means_and_error_bars_(ggplot2)/

  # The errorbars overlapped, so use position_dodge to move them horizontally
  pd <- position_dodge(1.5) # move them .05 to the left and right

  gg <- ggplot(tibble, aes(x=positionX / 3.281, y=mean, colour=transect, group=transect)) + 
    geom_errorbar(aes(ymin=mean-se, ymax=mean+se), colour="black", width=.1, position=pd) +
    geom_line(position=pd) +
    geom_point(position=pd, size=3, shape=21, fill="white") + # 21 is filled circle
  
    labs(title = paste("mean thomisidae collection rate: seasonal ",
                        periodString, sep=""),
       subtitle = "(daylight)",
       caption = paste(observations, 
                       " observations\n at each trap position", sep=""),
       x = "trap distance from field edge (m)", 
       y = "mean rate +/- SE (count / 8 hrs)") +
  
    scale_colour_hue(name="transect",    # Legend label, use darker colors
                     breaks=c("oakMargin", "control"),
                     labels=c("SNH", "control"),
                     l=40) +            # Use darker colors, lightness=40

    expand_limits(y=0) +                        # Expand y range
    scale_y_continuous() +
    scale_x_continuous(breaks = seq(0, 60, 20)) +
  
    theme_bw() 
  
  return(gg)
  
}


generateLikelihoodV3 <- function(df, daytime, fromDisc, path, randomSeed,  hp) {


  ##
  ##
  ## build a df of likelihood (the probability that the
  ## spider population is influenced by the oakMargin) by cluster by week
  ## UPDATE ELEMENT 5 of the inbound list (a list of 9 likelihoods) and 
  ## returning the new list.
  ##
  ## save a text file summary() of each model to disc
  ##
  ## return a plot the likelihoods
  ##
  ## return plots of the mcmc_intervals for 9 models
  ##

  ## parameter df is the 4th member of the output of evaluateDailySpiderCounts(bugs.df)

  ## parameter inboundList is the output of evaluateDailySpiderCounts(bugs.df)

  ## parameter hp is the hypotheticalPopulation used to generate likelihood

  
  if("rethinking" %in% (.packages())){
     detach("package:rethinking", unload=TRUE) 
  }
  
  # https://bookdown.org/connect/#/apps/1850/access
  library(brms)
  library(rstan)
  #For execution on a local, multicore CPU with excess RAM we recommend calling
  options(mc.cores = parallel::detectCores())
  #To avoid recompilation of unchanged Stan programs, we recommend calling
  rstan_options(auto_write = TRUE)

  fileName.rds <- paste(path, "listV2-", daytime, ".rds", sep="")

  inboundList <- list()


  if (fromDisc==TRUE) {   # read the structure from disk

    inboundList <- readRDS(fileName.rds)

    likelihood.df <- inboundList[[5]] 
    modelInput <- inboundList[[7]]        # a list of the 9 data sources
    modelOutput <- inboundList[[8]]       # a list of the 9 models
    label.list <- inboundList[[9]]        # 
    post.df.list <- inboundList[[10]]     # a list of the 9 posterior distributions


  } else {   # go through the tedious process of creating the brm models

  
    ## total.df ( = df) , generated by evaluateDailySpiderCounts()
    ##                    'am' plus 'pm' data per 'timeList <- c('am', 'pm')'
    ##
    ## multiple records per week with columns
    ## week, transect, time, cluster, totalSpiders
    ##
  
    # estimate different mean populations across 3 groups of weeks reflecting the 
    # seasonal population decline
    # 
    # week 23, 24, 25           : mean 75, sd 15
    # week 26, 27, 28, 29, 30   : mean 50, sd 8
    # week 31, 32, 33, 34       : mean 15, sd 2
    
    
    
    likelihood.df <- NULL
    modelInput <-list()
    post.df.list <- list()
    modelOutput <- list()

  
    cl.st.list <- list()  # for each cluster  
    # build list of dataframes represting the seasonal population 
    # plus a variable log-population
    #
    weekLabel.lst <- list()  # remember which cluster and seasonal timeframe
    weekLabel.lst[[1]] <- "week 23-25"
    weekLabel.lst[[2]] <- "week 26-30"
    weekLabel.lst[[3]] <- "week 31-34"


    #
    # lists containing parameters developed in evaluateDailySpiderCounts()
    # 
    # 34 observations of 8 variables
    # week, transect, time, cluster, totalSpiders, population, log_pop, contact_high
    #
    #
    # mean population for 9 models     :  inboundList[[11]]            
    #  

    cl.st.list <- list()
  
    cl.st.list[[1]] <- df %>% dplyr::filter(week < 26)
    cl.st.list[[1]]$population <- hp[[1]]  
    cl.st.list[[1]]$log_pop <- log(cl.st.list[[1]]$population)  # R code 10.40
    cl.st.list[[1]]$contact_high <- ifelse( cl.st.list[[1]]$transect=="oakMargin" , 1 , 0 )
    
    cl.st.list[[2]] <- df %>% dplyr::filter(week > 25 & week < 31)
    cl.st.list[[2]]$population <- hp[[2]]  
    cl.st.list[[2]]$log_pop <- log(cl.st.list[[2]]$population)  # R code 10.40
    cl.st.list[[2]]$contact_high <- ifelse( cl.st.list[[2]]$transect=="oakMargin" , 1 , 0 )
    
    cl.st.list[[3]] <- df %>% dplyr::filter(week > 30)
    cl.st.list[[3]]$population <- hp[[3]]  
    cl.st.list[[3]]$log_pop <- log(cl.st.list[[3]]$population)  # R code 10.40
    cl.st.list[[3]]$contact_high <- ifelse( cl.st.list[[3]]$transect=="oakMargin" , 1 , 0 )
    
  
    
    #### model building ####
    #### model building ####
    #### model building ####
    for (i in 1:length(cl.st.list)) {  # build model for each seasonal timeframe

      # ref: Oceanic Tool Complexity Model
      # https://bookdown.org/connect/#/apps/1850/access 
         
        b10.10 <- brm(data = cl.st.list[[i]], family = poisson,
              			totalSpiders ~ 1 + log_pop + contact_high + contact_high:log_pop,  # yes, + contact_high:log_pop
              			prior = c(prior(normal(0, 100), class = Intercept),
                        prior(normal(0, 1), class = b)),
             			iter = 3000, warmup = 1000, chains = 4, cores = 4, seed = randomSeed)

        #print(b10.10)

        modelInput[[i]] <- cl.st.list[[i]]
        modelOutput[[i]] <- b10.10
      

        post.df.list[[i]] <- brms::posterior_samples(modelOutput[[i]])  # 


        # adjust hypothetical population by seasonal timeframe 
        if (i == 1)  {
          hPop <- hp[[1]]
          seasonalTimeframe <- "one"
        } else if (i == 2) {
          hPop <- hp[[2]]
          seasonalTimeframe <- "two"
        } else {
          hPop <- hp[[3]]
          seasonalTimeframe <- "three"
        }  


 
        temp.df <- post.df.list[[i]] %>%   
          mutate(lambda_high = exp(b_Intercept + b_contact_high + (b_log_pop + `b_log_pop:contact_high`) * log(hPop) ),
                 lambda_low  = exp(b_Intercept + b_log_pop * log(hPop) ) ) %>% 
          mutate(diff        = lambda_high - lambda_low) 
        
        like.df <- temp.df %>%
          summarise(sum = sum(diff > 0)/length(diff))  # 
        
       
    
      	temp2.df <- data.frame(seasonalTimeframe, like.df$sum) 
      	# column names need to match for rbind() to work
      	names(temp2.df) <- c("seasonalTimeframe", "plausibility")
    
     	 # tack it on
      	if (!exists('likelihood.df')) {
        	likelihood.df <- temp2.df
        	# (so, on the first pass the column names are cool)
      	} else {
        	likelihood.df <- rbind(likelihood.df, temp2.df)
      	}
    
    }  
    #### end model building ####
    #### end model building ####
    #### end model building ####

    
    
    if (file.exists(fileName.rds)) { file.remove(fileName.rds) }

    inboundList[[5]] <- likelihood.df
    inboundList[[7]] <- modelInput  # that is a list of the 9 data sources
    inboundList[[8]] <- modelOutput  # that is a list of the 9 models
    inboundList[[9]] <- weekLabel.lst  # 
    inboundList[[10]] <- post.df.list

    saveRDS(inboundList, fileName.rds)

    } 


    ggList <- list()
    # plot the likelihood for the 3 models
    ggList[[1]] <- plotLikelihoodV2(tibble=as_tibble(likelihood.df),  hypoPop=hp,
                                  	cap=paste("(daylight hours)", sep=""))

    library(bayesplot)

    for (i in 1:3) {

      fileName.txt <- paste(path, "clBRMsummary-v2-", daytime, "-", i, ".txt", sep="")
      if (file.exists(fileName.txt)) file.remove(fileName.txt)

      sink(file=fileName.txt, append = TRUE, type = "output")
      print(writeLines(paste("generateLikelihoodV3()               ", "  i= ", i, sep="")))  # Sys.time(), 
        
      print(summary(modelOutput[[i]], prob=.89))
      sink(NULL)

    }



    # print the posterior graphs separately so that the color can be adjusted to match the cluster info

    for (i in 1:3) {

    	if (i == 1)  {
          color_scheme_set("red") # setting used by bayesplot mcmc_intervals()  
        } else if (i == 2) {
          color_scheme_set("green") 
        } else {
          color_scheme_set("blue") 
        }  

      # plot the posterior distributions
      ggList[[i+2]] <- post.df.list[[i]] %>%

      select(-lp__) %>% 
      rename(b_interaction = `b_log_pop:contact_high`) %>%

      bayesplot::mcmc_intervals(prob = .5, prob_outer = .89) +
      				theme(axis.ticks.y = element_blank(), axis.text.y  = element_text(hjust = 0)) +
      				theme_bw() +
      				ggplot2::labs(
        				caption = paste("posterior distribution coefficient plot\nmedians with 50% and 89% credible intervals",
                        " ; seasonal timeframe: ", weekLabel.lst[[i]], 
                        "\ninteraction plausibility: ", round(likelihood.df[[2]][[i]], 2), sep="") )
    }


  
      # reserved positions:
    # returnList[[1]]) # scatter plot by cluster with seasonal timeframes
    # returnList[[2]]) # scatter plot by am/pm
    # returnList[[3]]) # scatter plot by transect
    #
    # returnList[[4]] is the dataframe used for the graphics (total.df)
    # from bayes.R evaluateDailySpiderCounts()
    # it is raw, not averaged, bugs.df data transformed to : 
    #          ("week", "transect", "time", "cluster", "totalSpiders")
    #
    # returnList[[5]] <- likelihood.df
    # returnList[[6]]                   # likelihood by cluster with seasonal timeframes
    # returnList[[7]] <- modelInput     # that is a list of the 9 data sources
    # returnList[[8]] <- modelOutput    # that is a list of the 9 models
    # returnList[[9]] <- label.list     # 
  


    # cleanup

    rm(inboundList)
    rm(likelihood.df)
    rm(modelInput)
    rm(modelOutput)
    rm(weekLabel.lst)
    rm(post.df.list)

    #detach("package:rstan", unload=TRUE)  
    #detach("package:bayesplot", unload=TRUE)
    #detach("package:brms", unload=TRUE) 

  
    return(ggList)
  
}




plotLikelihoodV2 <- function(tibble, hypoPop, cap) {
  
  # input df :
  # seasonalTimeframe{one, two, three}, plausibility(decimal)
  #

  
  colours = c("three" = "blue", "two" = "green", "one" = "red")
  
  gg <- ggplot(tibble, aes(x=seasonalTimeframe, y=plausibility)) +
    
        #geom_point(aes(fill = "green"), shape = 21, size=5, show.legend=TRUE, width=0.05) +
        geom_point(aes(fill=colours), shape = 21, size=5, show.legend=TRUE, width=0.05) +
    
    	ylim(c(0, 1)) + 
    	expand_limits(y=c(0,1)) + 
 
    	labs(y="plausibility", 
         x="seasonal timeframe", 
         caption = paste("the plausibility of a positive SNH effect\non the crab spider population\n", 
                          cap, sep="") ) +
    
    	scale_x_discrete(labels=c("one" = "weeks\n23-25", "two" = "weeks\n26-31", "three" = "weeks\n32-34"),
    					limits=c("one", "two", "three")) +
    
    	# coord_fixed(1.5) + # control the aspect ratio of the output
    
    	theme_bw() +

    	theme(legend.position="none") 
  
  
  
  
  return(gg)
  
  
}

getRDS <- function() {

	# > five <- getRDS()
	# [1] "./code/output/listV2-pm.rds"
	# > five[[5]]
  	#	seasonalTimeframe plausibility
	# 1               one     0.029625
	# 2               two     0.468875
	# 3             three     0.763375
	# >

	setwd("/Users/rcphelps/code/thesis/ampelos")
	path <- "./code/output/"
	daytime <- "pm"

	fileName.rds <- paste(path, "listV2-", daytime, ".rds", sep="")

	print(fileName.rds)

	dataFromDisc <- list()
	# read the structure from disk

    dataFromDisc <- readRDS(fileName.rds)

    likelihood.df <- dataFromDisc[[5]] 
    modelInput <- dataFromDisc[[7]]        # a list of the 9 data sources
    modelOutput <- dataFromDisc[[8]]       # a list of the 9 models
    label.list <- dataFromDisc[[9]]        # 
    post.df.list <- dataFromDisc[[10]]     # a list of the 9 posterior distributions

    return(dataFromDisc)

}


modelDiagsV3 <- function(daytime, hp, rds) {


  prev.lst <- list()
  prev.lst <- readRDS(rds)

  post.df.lst <- list()
  post.df.lst <- prev.lst[[10]] 

  modelOutput.lst <- list()
  modelOutput.lst <- prev.lst[[8]]       # a list of the 3 models

  label.lst <- list()
  label.lst <- prev.lst[[9]]


  for (j in 1:3) {   

    # adjust hypothetical population by seasonal timeframe 
    if (j == 1) {
      hPop <- hp[[1]]
    } else if (j == 2) {
      hPop <- hp[[2]]
    } else {
      hPop <- hp[[3]]
    }  

    post.df.lst[[j]] <- post.df.lst[[j]] %>%   
          mutate(trappedSpiders_high = exp(b_Intercept + b_contact_high + (b_log_pop + `b_log_pop:contact_high`) * log(hPop) ),
                 trappedSpiders_low  = exp(b_Intercept + b_log_pop * log(hPop) )) %>% 
          #mutate(diff        = (trappedSpiders_high - trappedSpiders_low) / trappedSpiders_low )
          mutate(diff        = trappedSpiders_high - trappedSpiders_low) 

      names(post.df.lst[[j]])[names(post.df.lst[[j]])=='b_contact_high'] <- 'bc'
      names(post.df.lst[[j]])[names(post.df.lst[[j]])=='b_log_pop:contact_high'] <- 'bpc'

  }

  gg.lst <- list()

  # insert seasonal period flag into the data

  gg.lst[[1]] <- plotPosteriorDensityV2(t1 = as_tibble(post.df.lst[[1]] %>% mutate(period="1")), 
  										t2 = as_tibble(post.df.lst[[2]] %>% mutate(period="2")), 
  										t3 = as_tibble(post.df.lst[[3]] %>% mutate(period="3"))
    									)

  gg.lst[[2]] <- justJitterPlotV2(t1 = as_tibble(post.df.lst[[1]] %>% mutate(period="1")), weekString=label.lst[[1]])
  gg.lst[[3]] <- justJitterPlotV2(t1 = as_tibble(post.df.lst[[2]] %>% mutate(period="2")), weekString=label.lst[[2]])
  gg.lst[[4]] <- justJitterPlotV2(t1 = as_tibble(post.df.lst[[3]] %>% mutate(period="3")), weekString=label.lst[[3]])


  gg.models.lst <- modelComparisonV2(models=modelOutput.lst, daytime='pm', randomSeed=seed, debug=FALSE)

  gg.lst[[5]] <- gg.models.lst[[1]]
  gg.lst[[6]] <- gg.models.lst[[2]]
  gg.lst[[7]] <- gg.models.lst[[3]]


  gg.mcmc.lst <- list()
  gg.mcmc.lst <- modelMCMCcheckV2(models=modelOutput.lst, daytime=time, debug=FALSE)

  gg.lst[[8]] <- gg.mcmc.lst[[1]]
  gg.lst[[9]] <- gg.mcmc.lst[[2]]
  gg.lst[[10]] <- gg.mcmc.lst[[3]]



  rm(prev.lst)
  rm(post.df.lst)
  rm(modelOutput.lst)


  return(gg.lst)

}



plotPosteriorDensityV2 <- function(t1, t2, t3) {

	# transform weekly data to trap-daily data (divide by 10 traps * 3 or 2 measurements per week)

    colours = c("1" = "red", "2" = "green", "3" = "blue")

    gg <- ggplot() + 
   
    geom_density(data=t1, aes(x=diff/30, y=..scaled.., fill = period), alpha=.7, show.legend=TRUE, key_glyph = "dotplot") +
    geom_density(data=t2, aes(x=diff/30, y=..scaled.., fill = period), alpha=.7, show.legend=TRUE, key_glyph = "dotplot") +
    geom_density(data=t3, aes(x=diff/20, y=..scaled.., fill = period), alpha=.7, show.legend=TRUE, key_glyph = "dotplot") +

    # stat_density(aes(x=diff), geom="point") +   # there is some magic here to adjust legend shapes
    # https://stackoverflow.com/questions/46597079/change-the-shape-of-the-legend-in-density-plots-with-ggplot2
    
    geom_vline(xintercept=0) + #
    
    
    coord_cartesian(ylim=c(0, 1.1), xlim=c(-1.3, 1.3))  + # clip
    #coord_cartesian(ylim=c(0, 1.5), xlim=c(-3, 5))  + # clip

    scale_y_continuous(breaks = seq(min(0), max(1.5), by = .2)) +

    labs(y="density", 
         x="trapped Thomisidae rate\nSNH treatment compared to control (daylight hours)", 
         caption = paste("the distribution of the plausible\ndifference in the average rate of\ntrapped Thomisidae", sep="") ) +
    
    theme_bw() +

    scale_fill_manual(values = colours, 
                      breaks = c("1", "2", "3"),
                      labels = c("week 23-25", "week 26-31", "week 32-34")) +
    guides(shape = guide_legend(override.aes = list(shape = 21))) +  # define the shape presented in the legend

    
    theme(legend.title = element_blank(),
          legend.spacing.y = unit(0, "mm"), 
          legend.justification=c(1,0),
          panel.border = element_rect(colour = "black", fill=NA),
          aspect.ratio = 1, axis.text = element_text(colour = 1, size = 12),
          legend.background = element_blank(),
          legend.box.background = element_rect(colour = "black")) 

    return(gg)

}


justJitterPlotV2 <- function(t1, weekString) {

	colours = c("1" = "red", "2" = "green", "3" = "blue")

    gg <- ggplot() + 

    geom_jitter(data=t1, aes(x=bc, y=bpc, fill = period), shape=21, size=2, alpha=.3, 
      show.legend=TRUE) +

      # ggplot2 issue # 3460 
      # https://github.com/tidyverse/ggplot2/issues/3460
      # show.legend=TRUE, key_glyph = draw_key_dotplot(data=data.frame(), size=5)) +

    guides(fill = guide_legend(override.aes = list(size = 5, alpha = 1))) + 
    
    scale_y_continuous(breaks = seq(min(0), max(2), by = 1)) +
    scale_x_continuous(breaks=seq(-15,5,5)) + 
    
    labs(y="bpc", 
         x="bc", 
         caption = paste("the joint posterior distribution of bc and bpc\n", weekString, sep="") ) +
    
    theme_bw() +

    scale_fill_manual(values = colours, 
                      breaks = c("1", "2", "3"),
                      labels = c("week 23-25", "week 26-31", "week 32-34")) +

    scale_shape_manual(values = 21) +

    theme(legend.position="none") 

    return(gg)

}



modelComparisonV2 <- function(models, daytime, randomSeed, debug) {

  	# Statistical Rethinking, code 10.45 and Statistical Rethinking Recoded

  	# for the error 
  	#        ## Warning: 
	#        ## 2 (33.3%) p_waic estimates greater than 0.4. We recommend trying loo instead.
  	# see: https://stats.stackexchange.com/questions/304958/warnings-during-waic-computation-how-to-proceed

  library(brms)
  library(rstan)
  library(Rcpp)   # brms bug: avoids  
                  #         Error in cpp_object_initializer(.self, .refClassDef, ...) 
                  #         could not find function "cpp_object_initializer"
                  #         failed to create the sampler; sampling not done

  #For execution on a local, multicore CPU with excess RAM we recommend calling
  options(mc.cores = parallel::detectCores())
  #To avoid recompilation of unchanged Stan programs, we recommend calling
  rstan_options(auto_write = TRUE)


  noInteraction <- list()
  noContact <- list()
  noLogPop <- list()
  onlyIntercept <- list()
  gg.lst <- list()

  cl <- c("one", "two", "three")
  st <- c("weeks 23-25", "weeks 26-31", "weeks 32-34")
  cluster <- NULL
  timeframe <- NULL


  for (i in 1:length(models)) { 

    # logic from https://bookdown.org/connect/#/apps/1850/access

    # no interaction
    noInteraction[[i]] <- update(models[[i]], formula = totalSpiders ~ 1 + log_pop + contact_high)

    # no contact rate
    noContact[[i]] <- update(models[[i]], formula = totalSpiders ~ 1 + log_pop)

    # no log-population
    noLogPop[[i]] <- update(models[[i]], formula = totalSpiders ~ 1 + contact_high)

    # intercept only
    onlyIntercept[[i]] <- update(models[[i]], formula = totalSpiders ~ 1, seed=randomSeed)

    models[[i]]   <- brms::add_criterion(models[[i]], criterion = "waic")
    noInteraction[[i]] <- brms::add_criterion(noInteraction[[i]], criterion = "waic")
    noContact[[i]]     <- brms::add_criterion(noContact[[i]], criterion = "waic")
    noLogPop[[i]]      <- brms::add_criterion(noLogPop[[i]], criterion = "waic")
    onlyIntercept[[i]] <- brms::add_criterion(onlyIntercept[[i]], criterion = "waic")


    w <- brms::loo_compare(models[[i]], noInteraction[[i]], noContact[[i]], noLogPop[[i]], onlyIntercept[[i]], criterion = "waic")

    cbind(waic_diff = w[, 1] * -2, se= w[, 2] *  2) %>% 
    round(digits = 2)
 

    # detect seasonal timeframe 
    if ( i == 1 ) {
      timeframe <- st[[1]]
      color <- "red"
    } else if ( i == 2 ) {
      timeframe <- st[[2]]
      color <- "green"
    } else {
      timeframe <- st[[3]]
      color <- "blue"
    }  


    gg.lst[[i]] <- w %>% data.frame() %>% 
          tibble::rownames_to_column(var = "model") %>%
 
          ggplot(aes(x = reorder(model, -waic), 
                 y    = waic,
                 ymin = waic - se_waic,   # 4x "standard error" ~= 95% confidence interval
                 ymax = waic + se_waic
                 #color = model)) +
                 )) +
          theme_bw() +
          geom_pointrange(shape = 21, size=1, fill=color, show.legend = F) + 
          coord_flip() +
          labs(x = NULL, y = NULL,
                caption = paste("Watanabe-Akaike Information Criterion\n+/- the standard error\nseasonal timeframe: ", 
                  timeframe, ")", sep="") ) +
          theme(axis.ticks.y    = element_blank())


    if (debug) {
      break
    }


  }


  # cleanup

  rm(noInteraction)
  rm(noContact)
  rm(noLogPop)
  rm(onlyIntercept)

  #detach("package:brms", unload=TRUE) 
  #detach("package:rstan", unload=TRUE) 


  return(gg.lst)

}


modelMCMCcheckV2 <- function(models, daytime, debug) {

  # ref: https://www.rensvandeschoot.com/brms-wambs/
  # BRMS Tutorial: Applying the WAMBS – checklist
  #
  library(tidyr)
  library(brms)
  library(ggmcmc)
  library(mcmcplots) 

  # For execution on a local, multicore CPU with excess RAM we recommend calling
  options(mc.cores = parallel::detectCores())

  gg.lst <- list()


  # l2. Does the trace-plot exhibit convergence?


  for (i in 1:length(models)) { 

    modeltransformed <- ggmcmc::ggs(models[[i]]) # the ggs function transforms the BRMS output into a longformat tibble, 
                                            # that we can use to make different types of plots.

    gg.lst[[i]] <- ggplot(filter(modeltransformed, Parameter==c("b_Intercept", "b_log_pop", "b_contact_high", "b_log_pop:b_contact_high"), 
                                  Iteration>1000), aes(x=Iteration, y=value, col=as.factor(Chain))) +
                            geom_line() +
                            theme_bw() +
                            facet_grid(Parameter ~ .,scale='free_y',switch = 'y') +
                            labs(caption=paste("mcmc chains caterpillar plot\n", "i= ", i, sep=""), col= "chains")

    if (debug) {
      break
    }

  }

  # cleanup

  #detach("package:brms", unload=TRUE) 
  #detach("package:ggmcmc", unload=TRUE) 
  #detach("package:mcmcplots", unload=TRUE) 


  return(gg.lst)

}



plotRawWeeklyV2 <- function(day, night, where) {



  # plot daily spider counts, by week, differentiate by time
  
  # input 2 dataframes :
  #  week, transect, time{am, pm}, totalSpiders
  #

  # > head(total.df, 10)
  #   week  transect time totalSpiders
  #1    23 oakMargin   am             2
  #2    23 oakMargin   am             6
  #3    23 oakMargin   am             2
  #4    23 oakMargin   am             4
  #5    23 oakMargin   am             2
  #6    23 oakMargin   am             3
  #7    23 oakMargin   pm             1
  #8    23 oakMargin   pm             7
  #9    23 oakMargin   pm            14
  #10   23 oakMargin   pm             5
  
  #assign("plotWeekly.df", df, envir=.GlobalEnv)
  #assign("dfX", df, envir=.GlobalEnv)
  
  colours = c("pm" = "violet", "am" = "purple")
  
  gg <- ggplot() + 
    
    geom_jitter(data=day, aes(x=week, y=totalSpiders, fill=time), size=3, shape=21, alpha=.7, show.legend=TRUE, width=.2, height=.2) +
    geom_jitter(data=night, aes(x=week, y=totalSpiders, fill=time), size=3, shape=21, alpha=.7, show.legend=TRUE, width=.2, height=.2) +
    
    geom_vline(xintercept=25.5) + # seasonal timeframe seperators
    geom_vline(xintercept=31.5) + #
    
    ylim(c(0, 31)) + 
    expand_limits(y=c(0,31)) + 
    coord_fixed(ratio=1/4) +     # control the aspect ratio of the output; "ratio" refers to the 
  # ratio of the axis limits themselves
    
    scale_y_continuous(breaks = seq(min(0), max(65), by = 5)) +
    scale_x_continuous(breaks=seq(22,40,2)) + 
    
    # labs(title=paste("total spiders trapped by week", sep=""),
    labs(
         y="Thomisidae, daily counts", 
         x="week", 
         caption = paste(where, " transect population activity\nby collection time in three\nobserved seasonal periods", 
         				 sep="") ) +
    
    theme_bw() +

    scale_fill_manual(values = colours, 
                      breaks = c("am", "pm"),
                      labels = c("overnight", "daytime")) +
    
    theme(legend.title = element_blank(),
          legend.spacing.y = unit(0, "mm"), 
          #legend.position=c(.9,.7),
          legend.justification=c(1,0),
          panel.border = element_rect(colour = "black", fill=NA),
          aspect.ratio = 1, axis.text = element_text(colour = 1, size = 12),
          legend.background = element_blank(),
          legend.box.background = element_rect(colour = "black")) 
    
  
  
  return(gg)
  
}

getWeeks <- function(data) {

	# return a list of the weeks occurring in the dataset
	# https://stackoverflow.com/questions/29832411/use-dplyr-to-get-values-of-a-column

	library(dplyr)

	weeks <- data %>%
   				select(week) %>%
   				unique() %>% 
   				.$week

   	return(weeks)

}

scanBugPercentages <- function(df) {

  # calculate count and percent by week (columns) for each bug (rows)

  if (FALSE) {

    df <- bugs.df

  }

  weeks.vector <- getWeeks(df)
  bugList <- colnames(df[,5:22])

  bugPct <- as.data.frame(df %>% select(5:22) %>% names())   # bug names as first column
  # disapointing : https://stackoverflow.com/questions/42769650/how-to-dplyr-rename-a-column-by-column-index
  # bugPct <- bugPct %>% rename_at( 1, ~"column1" ) %>% tibble::column_to_rownames('column1')
  bugPct <- bugPct %>% rename_at( 1, ~"bugNames" )  # 

  pctColNames <- list()

  for (i in 1:length(weeks.vector)) {

    trim.tbl <- as.data.frame(df %>% filter(week == weeks.vector[[i]]) %>% select(5:22) %>% colSums()) # append column representing totals 
                                                                                                       # of each insect for week i
    trim.tbl <- cbind(trim.tbl,round(prop.table(trim.tbl)*100,2))  # append column representing the percent of each insect for week i

    colnames(trim.tbl) <- c(paste('week', weeks.vector[[i]], 'count', sep=""), paste('week', weeks.vector[[i]], 'pct', sep=""))
    rownames(trim.tbl) <- NULL

    pctColNames[[i]] <- paste('week', weeks.vector[[i]], 'pct', sep="")  # save the column names

    bugPct <- dplyr::bind_cols(bugPct, trim.tbl)

  }

  returnList <- list()
  returnList[[1]] <- bugPct        # count and percent by week (columns) for each bug (rows)
  returnList[[2]] <- pctColNames   # week23pct, week24pct, ....
  returnList[[3]] <- weeks.vector  # 23, 24, .....

  return(returnList)

}

createFamilyPercentages <- function(list) {

  # given the dataframe and a list of columns returned by scanBugPercentages, organize percentages 
  # by individual families, return dataframes for each family of insects showing pct by week 

  #        list[[1]]   # dataframe with all the data : count and percent by week (columns) for each bug (rows)
  #        list[[2]]   # list of columns that contain the weekly percentages
  #        list[[3]]   # vector of week numbers

  dfBase <- list[[1]] %>% dplyr::select(bugNames)  # one column of bugNames

  for (i in 1:length(list[[2]])) {    # get the percentage columns

    temp.df <- list[[1]] %>% dplyr::select(list[[2]][[i]])

    dfBase <- dplyr::bind_cols(dfBase, temp.df)

  }

  # dfBase is now columns of weekly insect pct and rows for each insect
  # we are transforming the data into dataframes for 'families' of specific insects
  # 
  # each will be the sum of the percentages for each species in the family
  #
  # dfAraneae :      columns:   otherPct   spiderPct   avePct    week
  #

  dfCrab <- dfBase %>% dplyr::filter(bugNames == 'Thomisidae..crab.spider.')  # remove all insects except spiders
  dfOther <- dfBase %>% dplyr::filter(bugNames == 'spider.other') 
  dfAraneae <- dplyr::union(dfCrab, dfOther)  # one row for each spider; columns are percent for each week
  dfAraneae <- squashFlip(df=dfAraneae, weekList=list[[3]], columnList=c('otherPct', 'spiderPct', 'week'))
  dfAraneae$family <- 'Araneae'

  dfDiptera <- dfBase %>% dplyr::filter(bugNames == 'Diptera..Agromyzidae..leafminer..') 
  dfDiptera <- squashFlip(df=dfDiptera, weekList=list[[3]], columnList=c('dipteraPct', 'week'))
  dfDiptera$family <- 'Diptera'

  dfH1 <- dfBase %>% dplyr::filter(bugNames == 'Braconid.wasp')
  dfH2 <- dfBase %>% dplyr::filter(bugNames == 'Halictus.sp....3.part..native.bee.')
  dfH3 <- dfBase %>% dplyr::filter(bugNames == 'Agapostemon.sp....green..native.bee.')
  dfH4 <- dfBase %>% dplyr::filter(bugNames == 'Osmia.sp...native.bee.')
  dfH5 <- dfBase %>% dplyr::filter(bugNames == 'Honey.Bee')
  dfH6 <- dfBase %>% dplyr::filter(bugNames == 'Bombus.californicus..bumble.')
  dfHymenoptera <- dplyr::union(dfH1, dfH2)
  dfHymenoptera <- dplyr::union(dfHymenoptera, dfH3)
  dfHymenoptera <- dplyr::union(dfHymenoptera, dfH4)
  dfHymenoptera <- dplyr::union(dfHymenoptera, dfH5)
  dfHymenoptera <- dplyr::union(dfHymenoptera, dfH6)
  dfHymenoptera <- squashFlip(df=dfHymenoptera, weekList=list[[3]], columnList=c('a', 'b', 'c', 'd', 'e', 'f', 'week'))
  dfHymenoptera$family <- 'Hymenoptera'

  dfHe1 <- dfBase %>% dplyr::filter(bugNames == 'Lygus.hesperus..western.tarnished.plant.bug.')
  dfHe2 <- dfBase %>% dplyr::filter(bugNames == 'pentamonidae...stinkBug.')
  dfHemiptera <- dplyr::union(dfHe1, dfHe2)
  dfHemiptera <- squashFlip(df=dfHemiptera, weekList=list[[3]], columnList=c('a', 'b', 'week'))
  dfHemiptera$family <- 'Hemiptera'

  dfLep1 <- dfBase %>% dplyr::filter(bugNames == 'checkerspot.butterfly')
  dfLep2 <- dfBase %>% dplyr::filter(bugNames == 'Pyralidae..Snout.Moth.') 
  dfLepidoptera <- dplyr::union(dfLep1, dfLep2)
  dfLepidoptera <- squashFlip(df=dfLepidoptera, weekList=list[[3]], columnList=c('a', 'b', 'week'))
  dfLepidoptera$family <- 'Lepidoptera'

  dfOther1 <- dfBase %>% dplyr::filter(bugNames == 'Orius..pirate.bug.')
  dfOther2 <- dfBase %>% dplyr::filter(bugNames == 'Diabrotica.undecimpunctata..Cucumber.Beetle.')
  dfOther3 <- dfBase %>% dplyr::filter(bugNames == 'other')
  dfOther4 <- dfBase %>% dplyr::filter(bugNames == 'ladyBug')
  dfOther5 <- dfBase %>% dplyr::filter(bugNames == 'pencilBug')
  dfOther <- dplyr::union(dfOther1, dfOther2)
  dfOther <- dplyr::union(dfOther, dfOther3)
  dfOther <- dplyr::union(dfOther, dfOther4)
  dfOther <- dplyr::union(dfOther, dfOther5)
  dfOther <- squashFlip(df=dfOther, weekList=list[[3]], columnList=c('a', 'b', 'c', 'd', 'e', 'week'))
  dfOther$family <- 'Other'


  if (FALSE) {  # a manual verification that the percentages sum to 1

    dfAraneae.temp <- dfAraneae %>% dplyr::select(sumPct)       # that's a dataframe every column except week
    dfDiptera.temp <- dfDiptera %>% dplyr::select(sumPct)
    dfHymenoptera.temp <- dfHymenoptera %>% dplyr::select(sumPct) 
    dfHemiptera.temp <- dfHemiptera %>% dplyr::select(sumPct) 
    dfLepidoptera.temp <- dfLepidoptera %>% dplyr::select(sumPct) 
    dfOther.temp <- dfOther %>% dplyr::select(sumPct) 

    dfTotal <- dplyr::bind_cols(dfDiptera.temp, dfHymenoptera.temp)
    dfTotal <- dplyr::bind_cols(dfTotal, dfHemiptera.temp)
    dfTotal <- dplyr::bind_cols(dfTotal, dfLepidoptera.temp)
    dfTotal <- dplyr::bind_cols(dfTotal, dfOther.temp)
    dfTotal <- dplyr::bind_cols(dfTotal, dfAraneae.temp)


    dfTotal <- transform(dfTotal, sum = rowSums(dfTotal, na.rm = TRUE))


  }

  returnList <- list()
  returnList[[1]] <- dfAraneae
  returnList[[2]] <- dfDiptera
  returnList[[3]] <- dfHymenoptera
  returnList[[4]] <- dfHemiptera
  returnList[[5]] <- dfLepidoptera
  returnList[[6]] <- dfOther

  return(returnList)

}


plotBugPercentages <- function(list, spidersOnly) {

  dfAraneae <- list[[1]]
  dfDiptera <- list[[2]]
  dfHymenoptera <- list[[3]]
  dfHemiptera <- list[[4]]
  dfLepidoptera <- list[[5]]
  dfOther <- list[[6]]

  if (spidersOnly==TRUE) {

    gg <- ggplot(dfAraneae) + 
    
      geom_point(aes(x=week, y=spiderPct, fill = "spiderPct"), shape=21, size=5, show.legend=TRUE) +
      geom_point(aes(x=week, y=otherPct, fill = 'otherPct'), shape=21, size=5, show.legend=TRUE) +

      scale_fill_manual(name = "", values = c("spiderPct" = "purple", "otherPct" = "violet"), labels = c("Thomisidae", "Araneae (other)")) +

      ylim(c(0, 30)) + 
      expand_limits(y=c(0,30)) + 
      #coord_fixed(ratio=1/4) +     # control the aspect ratio of the output; "ratio" refers to the 
      # ratio of the axis limits themselves
    
      scale_y_continuous(breaks = seq(min(0), max(30), by = 5)) +
      scale_x_continuous(breaks=seq(22,40,2)) + 
    
    
      #labs(title=paste("spider abundance", sep=""),
      #subtitle=paste("percent of total insects by week", sep=""), 
      labs(y="spider percentage", 
          x="week", 
          caption = paste("spider abundance\n", "percent of total insects by week", sep="") ) +
    
      theme_bw() +
    
      theme(legend.title = element_blank(),
          legend.spacing.y = unit(0, "mm"), 
          #legend.position=c(.9,.7),
          legend.justification=c(1,0),
          panel.border = element_rect(colour = "black", fill=NA),
          aspect.ratio = 1, axis.text = element_text(colour = 1, size = 12),
          legend.background = element_blank(),
          legend.box.background = element_rect(colour = "black")) 

    } else {

      colours = c("oakMargin" = "#405E00", "control" = "#9BCC94")

      gg <- ggplot() + 
    
        geom_jitter(data=dfOther, aes(x=week, y=sumPct, fill = family), shape=21, size=5, show.legend=TRUE) +
        geom_jitter(data=dfAraneae, aes(x=week, y=sumPct, fill = family), shape=21, size=5, show.legend=TRUE) +
        geom_jitter(data=dfDiptera, aes(x=week, y=sumPct, fill = family), shape=21, size=5, show.legend=TRUE) +
        geom_jitter(data=dfHymenoptera, aes(x=week, y=sumPct, fill = family), shape=21, size=5, show.legend=TRUE) +
        geom_jitter(data=dfHemiptera, aes(x=week, y=sumPct, fill = family), shape=21, size=5, show.legend=TRUE) +
        geom_jitter(data=dfLepidoptera, aes(x=week, y=sumPct, fill = family), shape=21, size=5, show.legend=TRUE) +

        scale_fill_manual(name = 'insect family', 
          values = c('black','green', 'blue', 'violet', 'purple', 'red'), 
          breaks = c("Other", 'Araneae', 'Diptera', 'Hymenoptera', 'Hemiptera', 'Lepidoptera'),
          labels = c("other", "Araneae", 'Diptera', 'Hymenoptera', 'Hemiptera', 'Lepidoptera')) +

        #guides(shape = guide_legend("insect family"))  +

        ylim(c(0, 100)) + 
        expand_limits(y=c(0,100)) + 
        #coord_fixed(ratio=1/4) +     # control the aspect ratio of the output; "ratio" refers to the 
        # ratio of the axis limits themselves
    
        #scale_y_continuous(trans='log10', breaks = seq(min(0), max(100), by = 20)) +
        scale_y_continuous(trans='log10') +
        annotation_logticks(sides='l') +

        scale_x_continuous(breaks=seq(22,40,2)) + 
    
    
        #labs(title=paste("insect abundance by taxonometric Order", sep=""),
        # subtitle=paste("percent of total population by week", sep=""),
        labs(y="percent", x="week", 
          caption = paste("insect abundance by taxonometric Order\n", "percent of total population by week", sep="") ) +
    
        theme_bw() +
    
        theme(legend.title = element_blank(),
          legend.spacing.y = unit(0, "mm"), 
          #legend.position=c(.9,.7),
          legend.justification=c(1,0),
          panel.border = element_rect(colour = "black", fill=NA),
          aspect.ratio = 1, axis.text = element_text(colour = 1, size = 12),
          legend.background = element_blank(),
          legend.box.background = element_rect(colour = "black")) 

      }
    
  return(gg)

}


squashFlip <- function(df, weekList, columnList) {

  # convert row wise percent occurrance of bugs across weeks to 
  # an average of these associated insects by week

  # 
  # inbound dataframe
  #
  #        bugNames   week1Pct   week2Pct  week3Pct  ...... 
  # bugA
  # bugB   
  #
  # weeklist   : a vector of week numbers occurring in the df
  # columnList : a vector of row names ultimately to be applied as column names


  if (FALSE) {
    df <- dfShort
    weekList <- list[[3]]
    columnList <- c('otherPct', 'spiderPct', 'week')
  }

  df <- df %>% dplyr::select(-bugNames)  # remove the bugNames column
  df <- df %>% rbind(as.character(weekList)) # add a row of week numbers
  colnames(df) <- NULL
  df <- as.data.frame(t(df)) # flip  = transpose https://stackoverflow.com/questions/6778908/transpose-a-data-frame
  colnames(df) <- columnList
  options(digits=4)  # https://stackoverflow.com/questions/26734913/r-converting-from-string-to-double
  for (i in 1:length(columnList)) {
    df[,columnList[[i]]] <- as.numeric(as.character((df[,columnList[[i]]]))) # https://stackoverflow.com/questions/3796266/change-the-class-from-factor-to-numeric-of-many-columns-in-a-data-frame
  }

  # now, just create an average of insects for this particular family dataframe. columnList represents the
  # column names including 'week'. We could truncate the list to remove 'week', 
  #          like so : columnList <- columnList [ - length(columnList) ] # ignore the week column (the last column in the list)
  # and then use the modified columnList to define the columns that need to be used for the average
  #           somewhat like : df <- df %>% rowwise() %>% dplyr::mutate(meanPct=mean(columnList))
  # but mutate() is choking on that list, I think it is due to the old bogey of dyplr not accepting clean variables.
  #            the solution may be here : https://datascience.blog.wzb.eu/2016/09/27/dynamic-columnvariable-names-with-dplyr-using-standard-evaluation-functions/
  # the other approach is to remove the 'week' column, creat the average, then re-add the week column.
  #
  
  temp.df <- df
  temp.df <- temp.df %>% dplyr::select(week)                # that's a dataframe containing only week
  df <- df %>% dplyr::select(-week)                         # that's a dataframe every column except week
  df <- transform(df, sumPct = rowSums(df, na.rm = TRUE))  # finally, escaping the nightmare of dplyr https://stackoverflow.com/questions/12486264/average-across-columns-in-r-excluding-nas
  df <- dplyr::bind_cols(df, temp.df)

  # returning dataframe
  #                                     /----------- use this average for graphing purposes
  # species1.Pct .... speciesX.Pct   avePct   week
  #
  #

  return(df)

}


